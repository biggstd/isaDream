# General Imports
import pandas as pd
import os
import sys
import glob
import json

# Bokeh imports
from bokeh.layouts import layout, widgetbox
from bokeh.models import ColumnDataSource, Select, HoverTool, TapTool, LinearInterpolator
from bokeh.plotting import figure, curdoc
from bokeh.models.widgets import Div, Tabs, Panel
from bokeh.palettes import Category10
from bokeh.transform import factor_cmap

metadata_dict = dict()


try:
    # Get the HTML session context in order to find the appropriate json filepath.
    args = curdoc().session_context.request.arguments

    # TODO: Create a utility module / function to handle this, as every
    # visualization is likely to require this feature.

    # Get the filename where a series of json files to be visualized
    # can be found.
    filepath = args.get('J')[0].decode("utf-8")
    # print('#'*80)
    # print(type(filepath))
    filepath = os.path.join('data', filepath)

    # print('#'*80)
    # print(filepath)

    # Change the filepath.
    # TODO: This may have unintended consequences.
    # os.chdir(filepath)

    # Create a list to hold the json files.
    json_files = list()

    for jfile in glob.glob(f"{filepath}/*.json"):
        with open(jfile, 'r') as curr_file:
            json_files.append(json.load(curr_file))

    # Create the lists to hold the dataframes and metadata dictionaries.
    df_list = list()

    # Iterate through the .json files.
    for md_dict in json_files:

        # print(md_dict)

        # Get the ID of this json file.
        curr_ID = md_dict.get("ID")

        # Create an entry in the metadata_dict for this file.
        metadata_dict[curr_ID] = md_dict

        # Get the associated data file.
        curr_datafile = md_dict.get("data_file")

        # Build the pandas dataframe for each data file.
        new_df = pd.read_csv(curr_datafile)

        # Build a key column that links this data to its meta data.
        new_df['metadata_key'] = curr_ID

        # Add any study factors found as their own column.
        study_factors = md_dict.get("study_factors")

        # Iterate through these factors, and add each one to its
        # own column in the newly minted dataframe.
        for factor_name in study_factors:
            # print(factor_name)
            value = md_dict["study_factors"][factor_name]
            new_df[factor_name] = value

        # Append the dataframe to the df_list.
        df_list.append(new_df)

    # Concatentate the dataframes generated.
    data_frame = pd.concat(df_list, ignore_index=True)

    # print(data_frame)
    # print(metadata_dict)

except Exception as inst:
    print('HTML SESSION READ FAILED')
    print(f'got {inst} as an error.')
    data_frame = pd.read_csv('/data/sipos_2006_talanta_fig_3_KOH.csv')
    data_frame['metadata_key'] = 'failure'
    metadata_dict['failure'] = "This is a failure."

# print(data_frame)
# print(metadata_dict)

COLORS = Category10
SIZES = list(range(6, 22, 3))


# Get the column names for use in the selectors.
columns = sorted(data_frame.columns)
discrete = [x for x in columns if data_frame[x].dtype == object]
continuous = [x for x in columns if x not in discrete]
quantileable = [x for x in continuous if len(data_frame[x].unique()) > 20]

print(discrete)
print(continuous)
print(quantileable)

# Assign the columnDataSources.
source = ColumnDataSource()


def update_data():
    """Upodates the Bokeh ColumnDataSource with subsets of data
    collected from a search result."""

    # Set the X and Y values to those selected by the user.
    source.data = dict(
        x=data_frame[x_selector.value],
        y=data_frame[y_selector.value],
    )

    # Iterate over the entire dataframe generated by the 'search'
    # function, and add all of these generated columns to the
    # Bokeh ColumnDataSource.
    for col in list(data_frame):
        source.add(data=data_frame[col], name=col)

    # print(list(data_frame))
    # print(data_frame)


def tap_select_callback(attr, old, new):
    """The callback function for when a user uses the TapTool to
    select a single data point.
    """
    new_index = new['1d']['indices'][0]
    md_key = source.data['metadata_key'][new_index]
    print(f'md key: {md_key}')
    layout.children[1].children[2] = build_metadata_paragraph(md_key)


def build_hover_tool():
    """Constructs a Bokeh HoverTool instance based on current selections.
    """
    hover = HoverTool(
        tooltips=[
            ('X, Y', '($x, $y)'),
            # ('ppm Al', '@{ppm aluminum}'),
            # ('[OH-]', '@{molarity hydroxide}'),
            # ('[Al] total', '@{Aluminate Molarity}')
        ]
    )
    return hover


def create_figure():
    """
    Create the bokeh plot.
    """
    update_data()

    panels = []

    for axis_type in ["linear", "log"]:

        fig = figure(
            name='primary_figure',
            width=600,
            x_axis_type=axis_type
        )

        sizes = 7
        if size.value != 'None':
            size_scale = LinearInterpolator(
                x=[min(source.data[size.value]), max(source.data[size.value])],
                y=[2, 15]
            )
            sizes = dict(field=size.value, transform=size_scale)

        if color.value != 'None':
            colors = factor_cmap(
                field_name=color.value,
                # palette=Category10[len(source.data[color.value].unique())],
                palette=Category10[10],
                factors=sorted(source.data[color.value].unique())
            )
        else:
            colors = "#31AADE"

        fig.circle(
            source=source,
            x='x',
            y='y',
            color=colors,
            size=sizes,
            legend=color.value,
        )

        fig.legend.location = "bottom_left"

        x_title = x_selector.value
        y_title = y_selector.value

        fig.xaxis.axis_label = x_title
        fig.yaxis.axis_label = y_title

        fig.add_tools(build_hover_tool())
        fig.add_tools(TapTool())

        panel = Panel(child=fig, title=axis_type)
        panels.append(panel)

    tabs = Tabs(tabs=panels, width=620)

    return tabs


def update_plot(attr, old, new):
    """
    Define the function to be run upon an update call.
    """
    layout.children[1].children[1] = create_figure()



def build_metadata_paragraph(md_key=None):
    """Constructs an HTML paragraph based on a given key."""
    # if key is None:
    if md_key is None:
        return Div(
            text="No data point selected.",
            width=300,
        )
    else:
        new_paragarph = Div(
            text=str(metadata_dict[md_key]),
            width=300,
        )
        return new_paragarph


# HTML Elements ---------------------------------------------------------------
title_div = Div(text="<h1>Aluminate CrossFilter</h1>")

# Controls and Selectors ------------------------------------------------------
source.on_change('selected', tap_select_callback)

x_selector = Select(title='X Axis', options=continuous, value=continuous[0])
x_selector.on_change('value', update_plot)

y_selector = Select(title='Y-Axis', options=continuous, value=continuous[1])
y_selector.on_change('value', update_plot)

color = Select(title='Color', value='None', options=['None'] + discrete)
color.on_change('value', update_plot)

size = Select(title='Size', value='None', options=['None'] + continuous)
size.on_change('value', update_plot)

controls = widgetbox([x_selector, y_selector, color, size])

layout = layout(
    children=[
        title_div,
        [controls, create_figure(), build_metadata_paragraph()],
    ],
    sizing_mode='fixed'
)

curdoc().add_root(layout)
curdoc().title = "test vis"
